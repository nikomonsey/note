

# key操作

| 命令             | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| keys *           | 查看当前库所有的key                                          |
| exists key       | 判断某个key是否存在，返回0表示不存在，返回1表示存在          |
| type key         | 查看你的key存储的数据是什么类型                              |
| del key          | 删除指定的key数据，阻塞删除，若删除的很慢，则进程阻塞        |
| unlink key       | 非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步处理中操作 |
| ttl key          | 查看还有多少秒过期，-1表示永不过期，-2表示已过期。默认为永不过期 |
| expire key 秒钟  | 为给定的key设置过期事件                                      |
| move key dbindex | 将当前数据库的 key移动到给定的数据库db 当中  dbindex取值范围为[0,15]，redis默认有16个数据库 |
| select dbindex   | 切换数据库【0-15】，默认为0                                  |
| dbsize           | 查看当前数据库key的数量                                      |
| flushdb          | 清空当前库                                                   |
| flushall         | 通杀全部库                                                   |
| INCR key         | 对 key 中存储的数值做加 1 操作。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。 |



# redis十大数据类型

redis中的数据都是用k-v键值对存储的，几乎所有的key都为String类型，这里说的数据类型值的是value的值

准确来说这十大数据类型只有六大数据类型，分别是String、List、Hash、Set、Zset、Stream。

其余的四种是对这数据类型封装出来的数据结构，分别是Bitmap(String)、HyperLogLog(String)、Geospatial(Zset)、BitField(String)。



备注：redis中命令不区分大小写，但是key区分大小写
			可用help @类型，获取类型的方法帮助	例如help @string



## redis字符串(String)

string是redis最基本的类型，一个key对应一个value。
string类型是二进制安全的（可以序列化的，因为实现了Serializable接口），意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象
string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M

Redis字符串又可以分为3类：
String：普通字符串
int：整数类型，可以做自增、自减操作
float：浮点类型，可以做自增、自减操作

不管是哪种字符串	最大空间都不能超过512M



### String类型的常用命令：

#### **SET和GET**

**`set key value [可选参数]`**：添加或者修改一个String类型的键值对

**`get key`**：根据key获取String类型的value，不存在返回nil 即null空

> 可选参数：
>
> EX：以秒为单位设置过期时间
>
> PX：以毫秒为单位设置过期时间
>
> EXAT：设置以秒为单位的时间戳为过期时间
>
> PXAT：设置以毫秒为单位的时间戳为过期时间
>
> NX：键不存在的时候添加键值对，存在返回nil
>
> XX：键存在的时候设置键值，也就是覆盖，不存在返回nil
>
> GET：返回指定键原本的值，若不存在返回nil
>
> KEEPTTL：保留键之前的生存时间，即在覆盖键值时过期时间还是之前的过期时间
>
> 提示：set命令使用EX、PX、NX参数，效果等同于SETEX、SETPX、SETNX。

```sh
set k2 v2 xx	#返回nil	因为k2不存在
set k2 v2
set k2 v2 xx	#返回ok	即k2存在，
set k3 v3 nx	#返回ok，因为k3不存在，所以创建


set name Tom	# 设置name=Tom
set name Bob get # 先返回原先name的值tom，再把name赋值为Bob
set name Bob ex 20 get # 重新设置name值并设置过期时间20秒，并返回之前的name值
get name	# 获取name的值
```

KEEPTTL：保留键之前的生存时间，即在覆盖键值时过期时间还是之前的过期时间

```sh
set name Tom ex 30	#设置name 30秒过期
set name Marry 	#修改name的值为 Marry
ttl name	#结果为-1，即我们修改name的值时，不会继承之前的过期时间，而是用默认永不过期
set name Marry KEEPTTL	#表示修改了之后，继承之前的过期时间
```

![2023-04-06_010246](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-06_010246.png)



```sh
set name Mike EXAT 1680715582	# 设置以秒为单位的时间戳的过期时间
set name Mike PXAT 1680715582123	# 设置以毫秒为单位的时间戳的过期时间

时间戳获取方式：java中
System.out.println(Long.toString(System.currentTimeMillis()/1000L));
获取当前以秒为单位时间戳，通过修改值，往后十几秒	不除以1000就为毫秒为单位
```

------



#### MSET和MGET

> M是multi的缩写，表示多个的意思。

mset表示批量增加	mget表示批量查询	批量增加不管key是否已经存在，存在就覆盖

```sh
mset k3 v3 k4 v4 k5 v5	#批量增加k3,k4,k5

mget k3 k4 k2	#批量查询k3,k4,k2
```

***





#### MSETNX

也为批量增加，区别在于为一个整体，只有要创建的key都不存在时，才会执行，若有一个key存在，则执行失败

```sh
keys *	#输出"k2""k1""k3""k4""k5"
msetnx k2 k6 k7
#输出 (error) ERR wrong number of arguments for 'msetnx' command
```

***





#### SETRANGE和GETRANGE

SETRANGE替换key存储数据中的一部分值	返回替换完之后key中存储数据的字符数
GETRANGE读取key存储数据中的一部分值

```sh
set k1 abcd1234		#设置k1存储数据为 abcd1234
GETRANGE k1 0 3		#输出为abcd	相当于subString 只是前后都闭区间[]而不是[)
SETRANGE k1 0 ljxxx		#返回k1存储数据的字符数8	相当于从第0个索引值开始替换 替换ljxxx.leng	
get k1	#返回	ljxxx234


GETRANGE k1 0 -1	#表示输出全部
```

***





#### INCR、INCRBY

> increase的缩写，表示自增

**`incr key`**：让一个整型的key自增1	只能是整型才能自增

```SH
set age 20
incr age	# 让age自增1
```

**`incrby key step`**：指定步长step，让一个整型的key自增step	step可以设置负数！！

```sh
incrby age 2	# 让age自增2
```

**`incrbyfloat key step`**：让一个浮点类型的数字指定步长自增（浮点类型只能指定步长自增，incrbyfloat也是用整型）

```sh
set weight 66.6
INCRBYFLOAT weight 0.2	# 让weight自增0.2
```

- **DECR、DECRBY、DECRBYFLOAT**

自减，操作和上述自增一样。

***





#### STRLEN

**`strlen key`**：获取key值的长度

```sh
strlen str # 获取str存储数据的长度
```

***





#### APPEND

**`append key value`**：在key值后追加内容value

```sh
append str hijklmn	# 在str值后追加内容hijklmn
```

***





#### GETSET

**`getset key value`**：设置键值对时先获取原先的key值再设置新的key值，等价于set key get。

```sh
getset k1 v1	#输出本身k1的值，再把v1存储覆盖到k1中
```





#### SETNX和SETEX

> setnx：已存在就不会改变键的值。NX是not exists的缩写。
>
> setex：设定键的过期时间。EX是expire的缩写。

**`setnx key value`**：如果key不存在则创建一个String类型的键值对，如果key存在，则不执行。创建成功返回1，失败返回0。

**`setex key second`**：创建一个String类型的键值对，并设置过期时间，second为秒数

主要用于分布式锁



## redis列表(List)

Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部〈右边)
它的底层实际是个双端链表，最多可以包含2^32- 1个无素(4294967295),每个列表超过40亿个元素

left、right端都可以插入添加;
如果键不存在，创建新的链表;
如果键已存在，新增内容;
如果值全移除，对应的键也就消失了。



### list类型常用命令：

#### LPUSH和RPUSH

> 向列表头部或尾部插入元素。返回值为执行命令后列表的长度。当key不存在时则创建key。

**`LPUSH key element [element ...]`**：在列表key左边添加一个或多个元素，也就是在列表的头部添加元素。

**`RPUSH key element [element ...]`**：在列表key右边添加一个或多个元素，也就是在列表的尾部添加元素。

```sh
lpush list A B	# 创建一个列表，key为list
lpush list C D E	# 在列表左边（前面）追加C、D、E三个元素
rpush list X Y Z	# 在列表右边（后面）追加X、Y、Z三个元素
```

![2023-04-06_051330](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-06_051330.png)



![2023-04-06_064933](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-06_064933.png)

***





#### LRANGE

没有RRANGE。	即只能从列表左边开始读取数据

**`LRANGE key start stop`**：返回列表 key中指定区间内的元素，区间以偏移量(索引) `start` 和 `stop` 指定。

> 0表示第一个元素，1表示列表第二个元素；-1表示列表最后一个元素，-2表示列表倒数第二个元素，以此类推。
>
> 如果start的下标比列表最大的下标end(LLEN list减一)还大，那么Lrange返回一个空列表。
>
> 如果stop的下标比end的下标还要大，Redis将stop的值设置为end。`0到-1表示列表的所有元素`。

```sh
LPUSH list 1 2 3
RPUSH list 11 22 33
LRANGE list 0 -1	#输出3 2 1 11 22 33	注意list是队列
```

***





#### LPOP和RPOP

> 弹出列表最左端或最右端的元素。

**`LPOP key [count]`**：移除列表最左侧的元素并返回该元素，没有则返回nil，count为移除的个数。

**`RPOP key [count]`**：移除列表最右侧的元素并返回该元素，没有则返回nil，count为移除的个数。

```sh
LRANGE list 0 -1	#输出 3 2 1 11 22 33
LPOP list		#输出 3	即把左边第一个元素3弹出出队
RPOP list		#输出 33	即把右边第一个元素33弹出出队

```

***



#### BLPOP和BRPOP

> B是blocking的缩写，表示阻塞的意思。
>
> 与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil。

**`BLPOP key [key ...] timeout`**：移除列表第一个元素并返回该元素，如果列表没有元素会阻塞队列直到等待超时或发现可弹出元素为止

**`BRPOP key [key ...] timeout`**：移除列表最后一个元素并返回该元素，如果列表没有元素会阻塞队列直到等待超时或发现可弹出元素为止

***







#### LINDEX

**`LINDEX key index`**：通过索引获取列表元素。

下标(index)参数 `start` 和 `stop` 都以 `0` 为底，也就是说，以 `0` 表示列表的第一个元素，以 `1` 表示列表的第二个元素，以此类推。

你也可以使用负数下标，以 `-1` 表示列表的最后一个元素， `-2` 表示列表的倒数第二个元素，以此类推。

如果 `index` 参数的值不在列表的区间范围内(out of range)，返回 `nil` 。如果 `key` 不是列表类型，返回一个错误。

```sh
LINDEX list 0		#输出第一个元素	-1表示最后一个元素 -2表示倒数第二个
```



***





#### LLEN

**`LLEN key`**：返回列表key的长度。

> 如果key不存在，则key被解释为一个空列表，返回0。
>
> 如果key不是一个列表类型返回一个错误。

***





#### LREM

> remove的缩写，移除指定元素。
>
> 返回值：被移除元素的数量。不存在的 `key` 被视作空表(empty list)，所以当 `key` 不存在时， LREM命令总是返回 0 。

**`LREM key count value`**：根据count的值，移除列表中与参数value相等的元素。

> `count` 的值可以是以下几种：
>
> - `count > 0` : 从表头开始向表尾搜索，移除与 `value` 相等的元素，数量为 `count` 。
> - `count < 0` : 从表尾开始向表头搜索，移除与 `value` 相等的元素，数量为 `count` 的绝对值。
> - `count = 0` : 移除表中所有与 `value` 相等的值。

```sh
LPUSH list a a a b b c c d d d	#设置数组 值为aaabbccddd
LREM list 4 a 	#从表头开始 删除list列表中4个a元素，列表中只有3个元素，不会报错，之后全部删掉
```

***





#### LTRIM

> 对一个列表进行修剪(trim)，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。

**`LTRIM key start stop`**：让列表key只保留`start`-`stop`区间的元素。成功返回ok，若key不是列表类型返回错误。

> 下标(index)参数 `start` 和 `stop` 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
> 也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。

```sh
LTRIM list 1 3		#删除list列表中除索引值1到3之外的元素
```

***





#### RPOPLPUSH

**`RPOPLPUSH list1 list2`**：将列表list1中的尾元素弹出插入到列表list2的头部，并返回该元素。

相当于从list1右边弹出数据放入list2左边

> 如果source不存在，返回nil。
> 如果source和destination相同，则列表中的表尾元素被移动到表头，并返回该元素，这种情况可以视为列表的旋转操作。

```sh
LPUSH list1 1 2 3 4 5
LPUSH list2 11 22 33 44 55
RPOPLPUSH list1 list2	#返回1	即list1右侧出队的数据1	从list2左侧入队
```

***





#### LSET

**`LSET key index value`**：将列表key下标为index的元素的值设置为value。操作成功返回ok。

> 当index参数超出范围，或对一个空列表(key不存在)进行LSET时，返回一个错误。关于更多的下标信息，参考LINDEX。

```sh
LPUSH list a b c d
lset list 1 e		#将list中索引值为1的元素替换为e
LRANGE list 0 -1	#输出aecd
```

***





#### LINSERT

**`LINSERT key BEFORE|AFTER element value`**：将值value插入到列表key中element元素之前或之后。

> 当`element`不存在列表`key`中时，不执行任何操作。当`key`不存在时，也不执行任何操作。若`key`不是列表类型，返回一个错误。
>
> 返回值：
> 如果命令执行成功，返回插入操作完成之后，列表的长度。
> 如果没有找到 `element` ，返回 `-1` 。
> 如果 `key` 不存在或为空列表，返回 `0` 。

```sh
LPUSH list a b c d
lINSERT list before 1 e		#再list中索引值为1的元素之前插入元素e
LRANGE list 0 -1	#输出aebcd
```



***













## redis哈希表(Hash)

Redis hash是一个string类型的 field(字段)）和value(值)的映射表，hash特别适合用于存储对象。

Redis中每个 hash 可以存储2^32-1键值对(40多亿)

之前存储为 k1 v1	哈希表数据类型为 k1 filed v1



### Hash类型的常用命令:

#### HSET和HGET

**`HSET key field value [field value ...]`**：将hash表key中的域field的值设置为value，支持同时设置多个域-值对。

> 如果key不存在，一个新的hash表被创建并执行HSET操作。
> 如果域field不存在，表示新增`field-value`(域值对)，如果域field已经存在哈希表key中，其旧值将被覆盖。
>
> 返回值：
> 如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。多个则返回对应的个数。
> 如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0。

**`HGET key field `**：根据给定域field返回对应的value值。当key不存在或者field不存在，返回nil。

相当于之前java的  Map<String,Map<String,String>>	在kv中再有一层kv

```sh
HSET user001 id 1 name tom score 99	#id 1 name tom score 99就是第二层kv id为k 1为value
HGET user001 name	#输出tom
```



------



#### HMSET和HMGET

**`HMSET key field value [field value ...]`**：同时将多个`field-value`（域-值对）设置到哈希表key中。

> 此命令会覆盖哈希表中已存在的域，如果key不存在，一个空的哈希表被创建并执行HMSET操作。
>
> 返回值：执行成功返回ok；若key不是hash类型，返回一个错误。
>
> HSET在Redis版本迭代后也支持同时设置多个值到哈希表中，与HMSET操作完全相同，HMSET今后可能被淘汰。不建议使用

**`HMGET key field [field ...]`**：返回哈希表key中一个或多个给定的域值。

> 如果给定的域不存在于哈希表，那么返回一个 `nil` 值。key不存在时也返回一个`nil`值。key不是Hash类型时报错。

```sh
HMGET user001 id name	#返回user001哈希表中 key id和name的value值
```



------



#### HGETALL

**`HGETALL key`**：返回哈希表key中所有的`field`和`value` 。

> 在返回值里，紧跟着域名后的是域的值，所以返回值的长度是哈希表大小的两倍。
>
> 返回值：以列表形式返回哈希表的域和值，若key不存在，返回空列表。若key不是hash类型则报错。
>
> 若在Redis客户端这样显示的数据就是列表：
> 1）"AA"
> 2）"BB"
> 3）"CC"
> ...

```sh
HGETALL user001 	#返回user001哈希表中所有的值
```



------



#### HDEL

**`HDEL key field [field ...]`**：删除哈希表 `key` 中的一个或多个指定域，不存在的域将被忽略。

> 返回值：被成功移除的域的数量，不包括被忽略的域。



------



#### HLEN

**`HLEN key`**：返回哈希表 `key` 中域的数量。

> 返回值：返回哈希表中域的数量，当key不存在时返回0，若key不是hash类型则报错。



------



#### HEXISTS

**`HEXISTS key field`**：查看哈希表key中，给定域field是否存在。

> 如果哈希表中存在给定域，返回 `1` 。
> 如果哈希表中不存在给定域，或 `key` 不存在，返回 `0` 。



------



#### HKEYS和HVALS

**`HKEYS key`**：获取哈希表key中所有的`field`

> 返回值：返回哈希表中所有field的`数组`，若key不存在返回一个空数组。若key不是hash类型返回错误。

**`HVALS key`**：获取哈希表key中所有field对应的`value`值。

> 返回值：返回哈希表中所有field对应的value的`数组`，若key不存在返回一个空数组。若key不是hash类型返回错误。

相当于java中的 keyset	values	分别获取key和vaue值

------



#### HINCR、HINCRBYFLOAT

**`HINCRBY key field increment`**：为哈希表 `key` 中的域 `field` 的值加上增量 `increment` 。只适用整型字符串

**`HINCRBYFLOAT key field increment`**：为哈希表 `key` 中的域 `field` 加上浮点数增量 `increment` 。只适用浮点型字符串

> 增量也可以为负数，相当于对给定域进行减法操作。
>
> 如果哈希表 `key` 不存在，那么会先创建一个哈希表，再创建域 `field` ，最后再执行`HINCRBY` 或 `HINCRBYFLOAT`操作。
>
> 如果域 `field` 不存在，那么在执行命令前，域的值被初始化为 `0` ，然后后执行`HINCRBY` 或 `HINCRBYFLOAT`操作。
>
> 对一个储存`非整型字符串`的域 field 执行 `HINCRBY` 命令将造成一个错误。
>
> 对一个储存`非数值型字符串`的域 field 执行 `HINCRBYFLOAT` 命令将造成一个错误。
>
> 本操作的值被限制在 64 位(bit)有符号数字表示之内。



------



#### HSETNX

**`HSETNX key field value`**：向哈希表key中添加`field-value`，当且仅当域field不存在。

> 若field已存在，则该操作无效；若key不存在，则创建该哈希表并执行HSETNX操作。
>
> 即不会覆盖之前的KV值，
>
> 返回值：添加成功，返回1；如果给定域已经存在返回 0 。

![2023-04-07_030549](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-07_030549.png)

------

------









## redis集合(Set)

> **集合**
>
> Redis的Set类型是一个和List一样的单key多value的集合，与List不同的是Set的value是无序且不可重复的。
>
> Redis的set相当于Java语言里面的HashSet，它内部键值对是无序的、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值NULL，可以看做是一个value为null的HashMap。
>
> 具备与HashSet类似的特征：
>
> - 无序 
> - 元素不可重复
> - 查找快
> - 支持交集、并集、差集等功能
>
> *应用场景*：
> 微信抽奖小程序。（SRANDMEMBER）
> 微信朋友圈共友点赞。（SINTER）
> QQ推荐可能认识的人。（SDIFF）



### Set类型的常用命令：

#### SADD

**`SADD key member [member ...]`**：将一个或多个 `member` 元素加入到set集合 `key` 当中，已经存在于集合的 `member` 元素将被忽略。

> 假如 `key` 不存在，则创建一个只包含 `member` 元素作成员的集合。
>
> 当 `key` 不是Set集合类型时，返回一个错误。
>
> **返回值**：被添加到集合中的新元素的数量，不包括被忽略的元素。

![2023-04-07_052026](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-07_052026.png)

------



#### SMEMBERS

**`SMEMBERS key`**：返回集合`key`中所有的成员。

> 若key不存在，返回空数组；若key不是Set集合，返回错误。

![2023-04-07_053352](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-07_053352.png)

------



#### SISMEMBER

> S表示Set集合，ISMEMBER表示is member？

**SISMEMBER key member**：判断 `member` 元素是否是集合 `key` 的成员。

> 如果 `member` 元素是集合的成员，返回 `1` 。
>
> 如果 `member` 元素不是集合的成员，或 `key` 不存在，返回 `0` 。

![2023-04-07_095412](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-07_095412.png)

------



#### SCARD

**`SCARD key`**：返回集合key中成员的个数。当key不存在时，返回0。若key不是Set集合类型，返回错误。

```sh
127.0.0.1:6379> SCARD course	# 获取集合course中元素的个数
(integer) 4
```

------



#### SREM

**`SREM key member [member ...]`**：移除集合key中的一个或多个member元素并返回移除的个数，不存在的member元素会被忽略。

```sh
127.0.0.1:6379> SREM course C++		# 移除C++
(integer) 1		# 成功移除一个

```

------



#### SRANDMEMBER

**`SRANDMEMBER key [count]`**：随机返回集合中一个[或多个]元素。仅仅返回随机元素，而不对集合进行任何改动。

>  SRANDMEMBER命令可选的 `count` 参数：
>
>  - 如果 `count` 为正数，且小于集合基数，那么命令返回一个包含 `count` 个元素的数组，数组中的元素**各不相同**。
>    如果 `count` 大于等于集合基数，那么返回整个集合。
>    - 如果 `count` 为负数，那么命令返回一个数组，数组中的元素**可能会重复出现多次**，而数组的长度为 `count` 的绝对值。即若count为负数，则返回的数组可能会重复
>
>  返回值:
>  只提供 `key` 参数时，返回一个元素；如果集合为空，返回 `nil` 。
>  如果提供了 `count` 参数，那么返回一个数组；如果集合为空，返回空数组。

![](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-07_113723.png)

------



#### SPOP

**`SPOP key [count] `** ：移除并返回集合中的一个[或多个]随机元素。

> 如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER命令。
>
> 返回值：被移除的随机元素。当 `key` 不存在或 `key` 是空集时，返回 `nil` 。

![2023-04-07_215248](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-07_215248.png)

------



#### SMOVE

**`SMOVE source destination member`**：将 `member` 元素从 `source` 集合移动到 `destination` 集合。

> SMOVE是原子性操作。
>
> 如果 `source` 集合不存在或不包含指定的 `member` 元素，则 SMOVE 命令不执行任何操作，仅返回 `0` 。
>
> 当 `destination` 集合已经包含 `member` 元素时， SMOVE 命令只是简单地将 `source` 集合中的 `member` 元素删除。
>
> 当 `source` 或 `destination` 不是集合类型时，返回一个错误。
>
> **返回值:**
>
> 如果 `member` 元素被成功移除，返回 `1` 。
>
> 如果 `member` 元素不是 `source` 集合的成员，并且没有任何操作对 `destination` 集合执行，那么返回 `0` 。

```sh
127.0.0.1:6379> sadd student 1 2 3 4 5
(integer) 5
127.0.0.1:6379> sadd course a b c d e
(integer) 5
127.0.0.1:6379> SMOVE student course a	#student集合中没有a元素，所以返回0
(integer) 0
127.0.0.1:6379> SMOVE student course 1
(integer) 1
127.0.0.1:6379> SMEMBERS student
1) "2"
2) "3"
3) "4"
4) "5"
```

------

#### 集合运算

相当于数学中的 差集 交集 并集

##### SDIFF

**`SDIFF key key2 ...`**：返回给定集合的差集。

> sdiff A B：返回属于集合A但不属于集合B的元素
> sdiff B A：返回属于集合B但不属于集合A的元素



##### SUNION

**`SUNION key [key ...]`**：返回给定集合的并集。

> 比如`sunion A B`表示返回集合A和集合B的所有元素，公共的只取一份。



##### SINTER

**`SINTER key [key ...]`**：返回给定集合的交集。

> 比如`sinter A B`表示即返回集合A和集合B共有的元素。

**`SINTERCARD numkeys key [key ...] [LIMIT limit]`** ：返回给定集合交集的个数。

> numkeys为key的个数。
>
> LIMIT为限制返回的个数的最大值，比如交集个数有10个，但是LIMIT为5，则返回5。

```sh
127.0.0.1:6379> sadd set1 1 2 3 x x a	#定义set1集合 123xxa
(integer) 5
127.0.0.1:6379> sadd set2 2 3 b c c a	#定义set2集合 23bcca
(integer) 5
127.0.0.1:6379> SDIFF set1 set2		#计算set1和set2的差集，即set1中有，set2中没有的元素
1) "x"
2) "1"	
127.0.0.1:6379> SUNION set1 set2	#计算set1和set2的并集	即set1加set2的元素
1) "b"
2) "a"
3) "2"
4) "1"
5) "3"
6) "c"
7) "x"
127.0.0.1:6379> sinter set1 set2	#计算set1和set2的交集	即set1和set2共同拥有的元素
1) "3"
2) "a"
3) "2"
127.0.0.1:6379> SINTERCARD 2 set1 set2	#2表示有两个key	
(integer) 3
127.0.0.1:6379> SINTERCARD 2 set1 set2 limit 2	#limit 2 现在返回个数 最多为2
(integer) 2
```



## redis有序集合(ZSet)

zset(sorted set:有序集合)

Redis zset和 set一样也是string类型元素的集合,和set不同的是	不允许重复的成员。
不允许重复的原因是：每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。
zset的成员是唯一的,但分数(score)却可以重复。

后加成员重复，则score会被覆盖

zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是О(1)。集合中最大的成员数为2^32- 1

Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。

SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。

score的值是一个*整型数值或者浮点数值*  的数，是可重复的。

SortedSet具备下列特性：

- 可排序
- 元素不重复
- 查询速度快



### Zset类型的常用命令：

#### ZADD

**`ZADD key score member [[score member] [score member] ...]`**：将一个或多个元素及其`score`值添加到有序集合`key`中。

> 如果某个 `member` 已经是有序集的成员，那么更新这个 `member` 的 `score` 值，并通过重新插入这个 `member` 元素，来保证该 `member` 在正确的位置上。
>
> `score`是一个用于排序的属性，它的值是整数值或双精度浮点数，`score`写在`member`的前面。
>
> 如果 `key` 不存在，则创建一个空的有序集并执行 `ZADD` 操作。当 `key` 存在但不是有序集类型时，返回一个错误。
>
> 当然还可以加其他参数比如`NX`、`XX`、`INCR`等等，对有序集的更多介绍参见 [sorted set](http://redis.io/topics/data-types#sorted-sets) 。

```sh
127.0.0.1:6379> zadd zset1 10 v1 20 v2 30 v3 40 v4	# 添加四个成员
(integer) 4		# 返回添加成功的个数
```

------



#### ZCARD

**`ZCARD key `**：返回有序集 `key` 中成员的个数。当key不存在时返回0，若key不是有序集类型，返回错误。

```sh
127.0.0.1:6379> ZCARD userZset		# 获取有序集userZset中成员的个数
(integer) 4		# 四个
```

------



#### ZCOUNT

**`ZCOUNT key min max`**：返回有序集 `key` 中， `score` 值在 `min` 和 `max` 之间(默认包括 `score` 值等于 `min` 或 `max` )的成员的数量。

> 默认情况下，区间的取值使用闭区间(小于等于或大于等于)，也可以通过给参数前增加 `(` 符号将其改变为开区间。
> 比如 `(1 5` 表示 1<score<=5，`(1 (5` 表示 1<score<5。
>
> （表示开区间	

```sh
127.0.0.1:6379> zadd zset1 10 v1 20 v2 30 v3 40 v4	#定义zset1
(integer) 4
127.0.0.1:6379> zcard zset1		#获取zset1集合元素个数
(integer) 4
127.0.0.1:6379> zcount zset1 20 30	#获取score20到30之间的元素个数
(integer) 2
127.0.0.1:6379> zcount zset1 (20 (30	#获取score20到30(不包含20和30)的元素个数
(integer) 0
```



------



#### ZSCORE

**`ZSOCRE key member`**：返回有序集 `key `中指定成员 `member` 的 `score` 值。

> 如果 `member` 元素不是有序集 `key` 的成员，或 `key` 不存在，返回 `nil` 。
>
> 返回值：`member` 成员的 `score` 值，以字符串形式表示。

![2023-04-08_180150](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-08_180150.png)

------



#### ZRANGE和ZREVRANGE

**`ZRANGE key start stop [WITHSCORES]`**：返回有序集合key中指定区间的成员。*从小到大排序*

> 其中成员的位置是按score值从小到大排序，具有相同score的车成员按字典序来排列。区间(下标参数)这里不再赘述。
>
> `WITHSCORES` 选项，表示让成员和它的 `score` 值一并返回，返回列表以 `member1,score1, ..., memberN,scoreN` 的格式表示。
> 可能会返回一些更复杂的数据类型，比如数组、元组等。
>
> 如果需要按score值从大到小排序，可以适用`ZREVRANGE`命令。

```sh
127.0.0.1:6379> ZRANGE zset1 0 -1
1) "v1"
2) "v2"
3) "v3"
4) "v4"
127.0.0.1:6379> ZRANGE zset1 0 -1 withscores	#withscores 带着score一起显示
1) "v1"
2) "10"
3) "v2"
4) "20"
5) "v3"
6) "30"
7) "v4"
8) "40"
```

**`ZREVRANGE key start stop [WITHSCORES]`**：返回有序集合key中指定区间的成员。*从大到小排序*

> 成员的位置是按照`score`值从大到小排序，其余都和`ZRANGE`一样。

![2023-04-08_045728](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-08_045728.png)

------



#### ZRANGEBYSCORE和ZREVRANGEBYSCORE

和zcount区别在于 zcount只是统计个数，而ZRANGEBYSCORE则是直接显示具体内容，通过withscores也可以显示score和内容

**`ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]`**：返回有序集 `key` 中所有 `score` 值介于 `min` 和 `max` 之间(包括等于 `min` 或 `max` )的成员。按score值*从小到大排序*

> 默认情况下，区间的取值使用闭区间(小于等于或大于等于)，也可以通过给参数前增加 `(` 符号来使用可选的开区间(小于或大于)。
> 比如 `(1 5` 表示 1<score<=5，`(1 (5` 表示 1<score<5。
>
> `LIMIT` 参数限制返回结果的区间(就像SQL中的 `SELECT ... LIMIT offset, count` )，offset为下标偏移量，count为个数。
>
> `WITHSCORES` 表示将有序集成员及其 `score` 值一起返回。

```sh
127.0.0.1:6379> ZRANGEBYSCORE zset1 10 40 #返回10到40的数据
1) "v1"
2) "v2"
3) "v3"
4) "v4"
#返回10到40的数据，带着score一起返回	且从返回数组索引值为1开始，显示2个
127.0.0.1:6379> ZRANGEBYSCORE zset1 10 40 limit 1 2 withscores
1) "v2"
2) "20"
3) "v3"
4) "30"
```

![2023-04-08_185848](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-08_185848.png)

**`ZREVRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]`**：返回有序集 `key` 中所有 `score` 值介于 `min` 和 `max` 之间(包括等于 `min` 或 `max` )的成员。按score值*从大到小排序*，其余参考ZRANGEBYSCORE。

------



#### ZRANK和ZREVRANK

**`ZRANK key member`**：返回有序集 `key` 中指定成员 `member` 的排名。*从小到大*

> 排名按 `score` 值递增(从小到大)顺序排列。排名以 `0` 为底，也就是说`score` 值最小的成员排名为 `0` 。
>
> 使用 `ZREVRANK` 命令可以获得成员按 `score` 值递减(从大到小)排列的排名。

![](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-08_181243.png)

**`ZREVRANK key member`**：返回有序集 `key` 中指定成员 `member` 的排名。*从大到小*

![2023-04-08_181658](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-08_181658.png)

------



#### ZREM

**`ZREM key member [member ...]`**：移除有序集key中一个或多个成员，不存在的成员将被忽略。

> 当key不存在时返回0；当key存在但不是有序集时返回一个错误。
>
> 移除成功返回移除成员的数量。

```sh
127.0.0.1:6379> ZADD testZset 10 A 20 B 30 C 40 D 50 E
(integer) 5
127.0.0.1:6379> ZREM testZset C D E		# 移除三个成员
(integer) 3		# 移除成功返回3
```

------



#### ZINCRBY

**`ZINCRBY key increment member`**：为有序集 `key` 的成员 `member` 的 `score` 值加上增量 `increment` 

> 可以通过传递一个负数值  ，让 `score` 减去相应的值，比如 `ZINCRBY key -5 member` ，就是让 `member` 的 `score` 值减去 `5` 。
>
> **返回值**：返回`member` 成员的新 `score` 值，以字符串形式表示。
> 当 `key` 不是有序集类型时，返回一个错误。
> 当 `key` 不存在，或 `member` 不是 `key` 的成员时， `ZINCRBY key increment member` 等同于 `ZADD key increment member` 。
>
> `score` 值可以是整数值或双精度浮点数。

![image-20230408193813874](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\image-20230408193813874.png)

------



#### ZPOPMAX和ZPOPMIN

**`ZPOPMAX key [count]`**：删除并返回有序集`key`中`score`值最大的一个[或多个]成员。

**`ZPOPMIN key [count]`**：删除并返回有序集`key`中`score`值最小的一个[或多个]成员。

![2023-04-08_200015](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-08_200015.png)

------



#### ZMPOP

**`ZMPOP numkeys key [key ...] <MIN | MAX> [COUNT count] `**：从所提供的键名列表中的第一个非空排序集中弹出一个[或多个]元素，这些元素是成员分数对。

> 这个指令就是ZPOPMAX和ZPOPMIN的升级版，可以对多个有序集合进行操作。

```sh
zadd zset1 10 v1 20 v2 30 v3 40 v4 50 v5
zadd zset2 10 a 20 b 30 c 40 d 50 e
zmpop 2 zset1 zset2 min count 1	#2 表示有两个key min表示将score最小的删除 count 1表示个数为1
#若一直执行上一行代码，则会一直从zset1中弹出元素，只有当zset1元素空了，才会开始弹zset2
#一次弹出两个元素，若这时zset1中只有一个元素，也不会先弹出zset2，而是只弹出zset1中最后一个元素
```

![2023-04-08_202047](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\2023-04-08_202047.png)

------













## redis地理空间(GEO)

Redis GEO主要用于存储地理位置信息，并对存储的信息进行操作，包括

添加地理位置的坐标。
获取地理位置的坐标。计算两个位置之间的距离。
根据用户给定的经纬度坐标来获取指定范围内的地理位置集合

即经纬度存储

### 常用方法

#### GEOADD

**`GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]`**	

将指定的地理空间项(经度、纬度、名称)添加到地理空间结构的key中。

数据以有序集的形式存储到键中，这样就可以使用GEOSEARCH命令查询项。

规定如下：

- 有效的经度从-180度到180度。
- 有效的纬度从-85.05112878度到85.05112878度。
- 当坐标位置超出上述指定范围时，该命令将会返回一个错误。

本质上是以zset的形式存储，只是score变成了经纬度 其他是一样的

```sh
127.0.0.1:6379> GEOADD city 116.403963 39.915119 "天安门" 116.403414 39.924091 "故宫" 116.024067 40.362639 "长城"		#将经纬度和地名对应存储
(integer) 3
127.0.0.1:6379> type city		#发现city的类型为zset，所以可以用zset相关的命令
zset
127.0.0.1:6379> ZRANGE city 0 -1	#通过zset命令查看city	发现中文乱码
1) "\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8"
2) "\xe6\x95\x85\xe5\xae\xab"
3) "\xe9\x95\xbf\xe5\x9f\x8e"
127.0.0.1:6379> quit		#退出登录
[root@localhost ~]# redis-cli -a 123456 --raw	#在登录时添加参数 --raw
127.0.0.1:6379> 
127.0.0.1:6379> ZRANGE city 0 -1	#再次查询发现显示
天安门
故宫
长城

```

***





#### GEOPOS

**`GEOPOS key member [member ...]`**：从给定的key里返回所有指定member的位置(经度和纬度)，不存在的member返回nil。

> GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。给定的位置元素不存在时， 对应的数组项为空值。直接空一行

```sh
127.0.0.1:6379> GEOPOS city 天安门 故宫 长城
116.40396326780319214
39.91511970338637383
116.40341609716415405
39.92409008156928252
116.02406591176986694
40.36263993239462167
```

------





#### GEOHASH

**`GEOHASH key member [member ...]`**：获取一个或多个`member`的geohash值。

geohash值，用于记录和使用，而不是使用长串的经纬度，通过算法生成的hash值，每个地点都不同

> 通常使用表示位置的元素使用不同的技术，使用Geohash位置52点整数编码。
> 由于编码和解码过程中所使用的初始最小和最大坐标不同，编码的编码也不同于标准。此命令返回一个标准的Geohash。	若给定的位置元素不存在，返回数组项也为空值，直接空一行

```sh
127.0.0.1:6379> GEOHASH city 天安门 故宫 长城
wx4g0f6f2v0
wx4g0gfqsj0
wx4t85y1kt0
```

------





#### GEODIST

**`GEODIST key member1 member2 [M | KM | FT | MI]`**：返回两个给定`member`之间的距离。

用于计算两地之间的距离

> 如果两个位置之间的其中一个不存在， 那么命令返回空值。
>
> - **m** 表示单位为米。
> - **km** 表示单位为千米。
> - **mi** 表示单位为英里。
> - **ft** 表示单位为英尺。
>
> 如果用户没有显式地指定单位参数， 那么 `GEODIST` 默认使用M作为单位。

```sh
127.0.0.1:6379> GEODIST city 天安门 长城
59338.9814		# 天安门距离长城59338.9814米	默认单位为m
127.0.0.1:6379> GEODIST city 天安门 长城 km
59.3390			# 天安门距离长城59.3390千米
```

------





#### GEORADIUS(核心方法)

**`GEORADIUS key longitude latitude radius <M | KM | FT | MI> [WITHCOORD] [WITHDIST] [WITHHASH] `**
**`[COUNT count [ANY]] [ASC | DESC] [STORE key] [STOREDIST key]`**

> 以给定的经纬度为中心， 返回key包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。
>
> radius：半径
>
> WITHDIST：在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。
>
> WITHCOORD： 将位置元素的经度和维度也一并返回。
>
> WITHHASH：将geohash值一并返回。
>
> COUNT ：限定返回的记录数。
>
> ASC：由近到远返回（升序）
>
> DESC：由远到近返回（降序）

```sh
假设当前所处位置为 北京王府井(116.418017 39.914402)
查看存储的city中哪个地方理我最近
# 由近到远排序	从city中查询	当前地址		以当前距离10km以内(10与km有空格)	返回10条
127.0.0.1:6379> GEORADIUS city 116.418017 39.914402 10 km withdist withcoord withhash count 10
天安门					  # member
1.2016					# 天安门距离北京王府井1.2km
4069885555089531		# geohash值
116.40396326780319214	# 经度值
39.91511970338637383	# 纬度值
故宫
1.6470					# 故宫距离北京王府井1.6km
4069885568908290
116.40341609716415405
39.92409008156928252
# 由远到近排序
127.0.0.1:6379> GEORADIUS city 116.418017 39.914402 10 km withdist withcoord withhash count 10 desc
故宫
1.6470
4069885568908290
116.40341609716415405
39.92409008156928252
天安门
1.2016
4069885555089531
116.40396326780319214
39.91511970338637383
```

------



#### GEORADIUSBYMEMBER

**`GEORADIUSBYMEMBER key member radius <M | KM | FT | MI> [WITHCOORD] [WITHDIST] [WITHHASH] `**
**`[COUNT count [ANY]] [ASC | DESC] [STORE key] [STOREDIST key]`**

> 以给定的位置元素为中心点，找出位于指定范围内的元素。其他和GEORADIUS命令一样。

查询的值一定要在city中有 才可以查到

```sh
# 获取距离天安10km范围内的位置元素
127.0.0.1:6379> GEORADIUSBYMEMBER city 天安门 10 km withdist withcoord withhash count 10 desc
故宫
0.9988
4069885568908290
116.40341609716415405
39.92409008156928252
天安门
0.0000
4069885555089531
116.40396326780319214
39.91511970338637383
```

------

------





## redis基数统计(HyperLogLog)

HyperLogLog是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的。

**基数统计**

HyperLogLog是一种概率数据结构，用于计数唯一的事物(技术上这是指估计一个集合的基数)。
(基数就是一个数据集中去除重复数据后总的个数)

HyperLogLog的数据类型还是String。在Redis中的HyperLogLog，虽然技术上是不同的数据结构，但被编码为Redis字符串。

在Redis里面每个HyperLogLog键只需要花费12kb内存就可以统计接近2^64个不同元素的基数。

HyperLogLog只会根据输入的元素来计算基数，不会存储输入的元素本身，所以HyperLogLog不能像集合那样返回输入的元素。！！！！

当淘宝要统计当天访问人数，数据量巨大，就可以使用基数统计

**什么是基数**	是一种数据集，去掉重复的真实个数



### HyperLogLog结构的常用命令：

#### PFADD

**`PFADD key element [element ...]`**：将元素element添加到HyperLogLog结构的key中。

> 如果 HyperLogLog 的内部被修改了,那么返回 1,否则返回 0 。
>
> 如果在调用该命令时仅提供变量名而不指定元素也是可以的，如果这个变量名存在，则不会有任何操作。如果不存在，则会创建一个数据结构（返回1）。

```shell
127.0.0.1:6379> PFADD hll a b c c d d f f g g	# 添加10个元素
(integer) 1		# 添加了10个元素，返回1
127.0.0.1:6379> PFADD hll a b c c d d f f g g	# 重复添加，HLL内部没有改变，返回0
(integer) 0
```

------



#### PFCOUNT

**`PFCOUNT key [key ...]`**：返回给定HyperLogLog结构的key的基数。

> 当参数为一个key时，返回存储在HyperLogLog结构体的该key的近似基数，如果该变量不存在，则返回0。
>
> 当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的。

```sh
127.0.0.1:6379> PFADD hll a b c c d d f f g g
(integer) 0	
127.0.0.1:6379> PFCOUNT hll		# 统计hll的基数（去重统计）
(integer) 6
```

------



#### PFMERGE

**`PFMERGE destkey [sourcekey [sourcekey ...]]`**：将多个HyperLogLog合并成一个HyperLogLog。

> destkey是合并后的HyperLogLog结构。
>
> 这个命令可以用PFCOUNT命令实现。

```sh
127.0.0.1:6379> PFADD hll1 a a b b c c d e f	# 创建一个HyperLogLog结构的hll1
(integer) 1
127.0.0.1:6379> PFADD hll2 d e f g g h h i i	# 创建一个HyperLogLog结构的hll2
(integer) 1
127.0.0.1:6379> PFMERGE hll3 hll1 hll2			# 合并这两个HyperLogLog结构的key存储到hll3中
OK
127.0.0.1:6379> PFCOUNT hll3					# 统计合并后HyperLogLog结构的hll3的基数
(integer) 9
127.0.0.1:6379> PFCOUNT hll1 hll2				# 直接统计hll1和hll2
(integer) 9
```

------

------









## redis位图(bitmap)

由0和1状态表现的二进制位的bit数组

![image-20230523134724098](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\image-20230523134724098.png)

用String类型作为底层数据结构实现的一种统计二值状态的数据类型。所以type key 得到的值任然是string

位图本质是数组，该数组由多个二进制位组成，其值只能是1或0，默认0，每个二进制位都对应一个偏移量(我们称之为一个索引)。

Bitmap支持的最大位数是2^32位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息。

常用于签到，点赞等，只有两个状态 要么签到，要么没签到，可用0，1表达
当用于签到时，一周只需要用1字节记录，一个月4个字节，而用mysql则需要多倍以上的资源

### Bitmap结构的常用命令：

#### SETBIT和GETBIT

SETBIT **`SETBIT key offset value`**：设置key的value(字符串)在offset处的bit值。
返回值为本身在offset处原来的值

```sh
SETBIT bit1 0 1	#设置bit位图 第1位 设置为1
SETBIT bit1 1 1	#设置bit位图 第2位 设置为1	不设置的位 默认为0
```

GETBIT	**`GETBIT key offset`**：返回key对应的value在offset处的bit值。

```sh
getbit bit1 1	#返回bit位图 第1位的值
getbit bit1 100	#当offset超出了bit1字符串长度(位图还是由string实现的) 会由0填充空间
```

***





#### STRLEN

**`STRLEN key `**：

返回该位图所占字节大小，而不是字符串长度！！！

位图以8位为1个字节

```sh
127.0.0.1:6379> setbit bit1 0 1
(integer) 0
127.0.0.1:6379> setbit bit1 1 1	
(integer) 0
127.0.0.1:6379> STRLEN bit1		#查询所占字节长度为1，位图计算字节 以8位为1个字节
(integer) 1
127.0.0.1:6379> setbit bit1 8 1	#在索引值为8，即在第9位 设置值，相当于用了第2个字节
(integer) 0
127.0.0.1:6379> STRLEN bit1		#所以这里返回2，即使第2个字节其他位还没用，只要用了1个就算被使用
(integer) 2
```

***





#### BITCOUNT

**`BITCOUNT key [start end [byte|bit]]`**：	统计key位图中比特位为1的个数

若写了start和end的值，默认就为byte 字节为单位

byte表示一个字节为一个偏移量，bit表示一个位为一个偏移量。

```sh
127.0.0.1:6379> BITCOUNT bit1	#在上一个bit1记录之上，查询比特位为1的个数为4
(integer) 4
127.0.0.1:6379> BITCOUNT mybit 3 6 bit	#查询比特[3,6]区间中比特位为1的个数(包含3和6)

127.0.0.1:6379> BITCOUNT mybit 1 -1 byte	#查询第2个字节到最后1个字节中 比特位为1的个数
#字节也是索引值，从0开始
```



#### BITOP(重！！)

**`BITOP operation destkey key [key ...]`**：	对一个或多个保存二进制位的字符串key进行位运算，并将结果保存到destkey中。！！！

```sh
127.0.0.1:6379> setbit bit1 0 1
(integer) 0
127.0.0.1:6379> setbit bit1 1 1
(integer) 0
127.0.0.1:6379> setbit bit1 2 1		#设置bit1的0 1 2设为1

127.0.0.1:6379> setbit bit2 0 1
(integer) 0
127.0.0.1:6379> setbit bit2 1 1
(integer) 0
127.0.0.1:6379> setbit bit2 3 1		#设置bit2的0 1 3设为1
(integer) 0
127.0.0.1:6379> BITOP and k3 bit1 bit2	#将bit1和bit2中同为1的相同比特位数保存到k3
(integer) 2			#返回为2	因为bit1和bit2有 0和1位的比特都为1
127.0.0.1:6379> getbit k3 0		#查询k3的第1个字节	返回结果为1	说明bit1和bit2在第1个字节都为1
(integer) 1

```



## redis位域(bitfield)

通过bitfield命令可以一次性操作多个比特位域(指的是连续的多个比特位)，它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。



set k1 hello	将k1的值设为hello，而在内存中存储hello，是以二进制的形式存储，就像java中 是在jvm虚拟机中以二进制的形式操作程序

h 二进制为 0110 1000 e 0110 0101

hello就为  0110100001100101011011000110110001101111 每8位对应一个字母，也对应一个十进制

而bitfield 就是直接修改二进制中对应位的值，来改变对应的字母

底层也是String类型



<u>***Bitfield结构的常用命令：***</u>

#### BITFIELD

**`BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] `**
**`[OVERFLOW WRAP|SAT|FAIL]`**

> 此命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。
>
> 其中可支持 get set incrby命令
>
> - GET <type> <offset> ：返回指定的位域的数值。
> - SET <type> <offset> <value> ： 设置指定位域的数值并返回它的原值。
> - INCRBY <type> <offset> <increment> ： 自增或自减（如果increment为负数）指定位域的值并返回它的新值。
>
> type 表示以几位 为一组 i8表示以8位为1组，有符号 把第1位看成符号  u4表示以4位为1组 无符号
>
> offset表示偏移量，i8 2 表示从第3位开始，取后8位作为一组，进行操作
>
> 还有一个命令通过设置溢出行为来改变调用`INCRBY`指令的后序操作：OVERFLOW [WRAP|SAT|FAIL]
> wrap：使用回环方式处理有符号整数和无符号整数的溢出情况。 默认处理方法
> sat：使用饱和计算方式处理溢出，下溢计算的结果为最小的整数值，上溢计算的结果为最大的整数值。
> fail：命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行。
>
> 有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。

| 字母 | 数值 | 二进制（高位->低位） |
| :--: | :--: | :------------------: |
|  h   | 104  |      0110 1000       |
|  e   | 101  |      0110 0101       |
|  l   | 108  |      0110 1100       |
|  l   | 108  |      0110 1100       |
|  o   | 111  |      0110 1111       |
|  x   | 120  |      0111 1000       |

- **GET和SET选项**

```sh
127.0.0.1:6379> set mybitfield hello
OK
127.0.0.1:6379> BITFIELD mybitfield get i8 0	# 以8位位一组，偏移量0表示第一个字符
1) (integer) 104	# 返回该字符对应的十进制值数值
#hello为0110100001100101011011000110110001101111	i8表示以8位为一组进行分组，0表示从第一个字节开始分组，往后取8个字节	前8位为01101000 十进制为104 ascii码为h
127.0.0.1:6379> BITFIELD mybitfield get i8 8	# 偏移量8表示第二个字符(8位为1个字符)
1) (integer) 101
#i8 8表示从第8个字节开始分组 往后取8个字节
127.0.0.1:6379> BITFIELD mybitfield get i8 16
1) (integer) 108
127.0.0.1:6379> BITFIELD mybitfield get i8 24
1) (integer) 108
127.0.0.1:6379> BITFIELD mybitfield get i8 32
1) (integer) 111
127.0.0.1:6379> BITFIELD mybitfield set i8 32 120	#将偏移量为32的那一组的数值替换为120(字母x)	即在hello中 o为字节32之后 取8位  替换位120 即x
1) (integer) 111
127.0.0.1:6379> get mybitfield
hellx	#最后显示hellx
```

- **INCRBY选项**

```sh
127.0.0.1:6379> set fieldkey hello
OK
127.0.0.1:6379> BITFIELD fieldkey incrby u4 2 1	# 从第三个比特位开始，对接下来的4位无符号数加1
1) (integer) 11		# 返回指定域增加后的数值
#hello前8位为01101000	u4 2 1 从第三个字节 往后取4个字节为一组 即1010 加1 变为 1011 十进制11
127.0.0.1:6379> get fieldkey	# 因为比特位的数值发生了变化，所以对应的数值也会发生变化，对应的字母也就变了
lello
127.0.0.1:6379> BITFIELD fieldkey incrby u4 2 1
1) (integer) 12
127.0.0.1:6379> BITFIELD fieldkey incrby u4 2 1
1) (integer) 13
127.0.0.1:6379> BITFIELD fieldkey incrby u4 2 1
1) (integer) 14
127.0.0.1:6379> BITFIELD fieldkey incrby u4 2 1
1) (integer) 15
127.0.0.1:6379> BITFIELD fieldkey incrby u4 2 1	#4位表示最大的数为15，溢出控制默认为wrap（循环溢出），超出后从0开始	即循环溢出 超过从0开始
1) (integer) 0	# 从0开始
```

- **OVERFLOW选项**

  bitfield中有三种关于数据溢出之后的控制

  wrap 若无符号超出之后从0开始	若有符号 正数超出之后 从-128开始（默认使用wrap，即不加overflow）

  sat：使用饱和计算方式处理溢出，下溢计算的结果为最小的整数值，上溢计算的结果为最大的整数值。
  即 取128或188这种从上溢出 则结果就为127 若取-129或-188这种从下溢出 则取-128

  fail：命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行。

```sh
127.0.0.1:6379> set fieldkey2 a
OK
127.0.0.1:6379> BITFIELD fieldkey2 overflow sat set i8 0 126	# 从偏移量0开始后八位对应的数值改为126
1) (integer) 97		# 返回之前的数值
127.0.0.1:6379> get fieldkey2
"~"					# 126对应这个~符号
127.0.0.1:6379> BITFIELD fieldkey2 overflow sat set i8 0 128	# 将数值改为128（超出了8位表示的最大值127）
1) (integer) 126	# 返回之前的数值
127.0.0.1:6379> get fieldkey2
"\x7f"				# 127对应的编码
127.0.0.1:6379> BITFIELD fieldkey2 overflow sat set i8 0 128	# 再次改为128
1) (integer) 127	# 使用sat溢出控制，超出了最大值的表示范围会取最大值127
127.0.0.1:6379> BITFIELD fieldkey2 overflow fail set i8 0 128	# 使用fail溢出控制，再次改为128
1) (nil)			# 使用fail溢出控制，超出了最大值的表示范围返回nil
```







## redis流(Stream)

Redis Stream 主要用于消息队列(MQ，Message Queue)

> **流**
>
> Redis流是一种数据结构（Stream类型），它的作用类似于只能追加的日志。您可以使用流来实时记录和同时聚合事件。
>
> Redis流用例示例包括:
>
> - 事件来源(例如，跟踪用户操作、点击等)
>
> - 传感器监测(例如，来自现场设备的读数)
>
> - 通知(例如，在单独的流中存储每个用户通知的记录)
>
> Redis为每个流消息生成一个唯一的ID，可以使用这些id检索它们关联的消息，或者读取和处理流中的所有后续消息。
>
> 四种和ID有关的特殊符号：
> `-`和`+`：当前流中最小ID和最大ID
> `$`：表示大于当前流中最大的id，用于新添加的消息
> `>`：用于XREANGROUP命令，表示迄今没有发送给组中使用者的信息，会更新消费者组的最后ID
> `*`：用于XADD命令中，表示让系统自动生成ID

MQ消息中间件，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。

**消息队列（Message Queue，简称MQ），指保存消息的一个容器，本质是个队列。**

可以通过list数据类型简单实现 左近右出 先进先出 但是效率低，且实现的是点对点的模式

![image-20230524083246630](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\image-20230524083246630.png)

redis发布订阅(pub/sub)可以实现一对多的通信，但是有个缺点就是消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃。而且也没有Ack机制来保证数据的可靠性，假设一个消费者都没有，那消息就直接被丢弃了。

![image-20230524083137095](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\image-20230524083137095.png)





Stream流就是Redis版的MQ消息中间件+阻塞队列，它能实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。

![stream原理](C:\Users\ljxxx\Desktop\student\java\笔记\tempphoto\stream原理.png)

> 一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容
>
> Message Content：消息内容
>
> Consumer group：消费组，通过XGROUP CREATE 命令创建，同一个消费组可以有多个消费者
>
> Last_delivered_id：游标，每个消费组会有个游标 last_delivered_id，任意一消费者读取了消息都会使游标 last_delivered_id 往前移动。保证了每次消费者读取的消息，都是没读取过的
>
> Consumer：消费者，消费组中的消费者
>
> Pending_ids []：客户端中会出现，读取了消息但是还未签收的情况，Pending_ids变量为数组，记录了该消费者已经读取的消息，但还未ack(确认字符)，即还未签收。它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。即确定了哪些消息是已读已签收，哪些消息是已读但是没签收，保证了消息不会丢失



### 生产者常用命令：

#### XADD

**`XADD key [NOMKSTREAM]  <* | id> field value [field value ...] `**

> 将消息追加到指定流`key`的末尾，添加的消息ID要比上个消息的ID大。如果key不存在，将自动创建流key然后执行XADD操作。
>
> ID用于标识给定消息，如果指定ID为*，则表示系统会自动生成一个唯一ID，相当于mysql中的自增主键
> ID由 时间戳-序列号组成(1681002319038-0)前半段为毫秒时间戳，后半段0表示该毫秒生成的第一条消息，后半段为64位长度，理论上同一毫秒生成的数据量无法达到这个级别
> 若是我们自己写ID值，也要按照格式来写，且要保证要比上一条消息的ID大	
>
> 该命令返回添加的消息的ID。如果ID参数传的是`*`，那么ID是自动生成的， 否则，命令仅返回用户在插入期间指定的相同的ID。
>
> 通常使用命令`XADD ID filed value [field value ...]`，其他的花里胡哨的参数了解即可。

```sh
127.0.0.1:6379> XADD mystream * name tom age 20	#添加一条消息到mystream队列末尾，自动生成id
"1684919509306-0"	#返回生成消息的id
127.0.0.1:6379> XADD mystream * name mark age 22
"1684919517032-0"
#自定义id	但是指定的id比上一条消息小 添加失败 报错！！
127.0.0.1:6379> XADD mystream 1684919509306-1 name marry age 18
#指定的id比上一条消息大，为同一毫秒的第二条消息，添加成功不报错
127.0.0.1:6379> XADD mystream 1684919517032-1  name marry age 18
"1684919517032-1"

```

------



#### XRANGE

**`XRANGE key start end [COUNT count]`**：返回给定id范围内流key的消息。

> id范围由[start,end]指定。特殊ID：`-` 表示流中最小的消息id，`+`表示流中最大的消息id。
>
> 返回的消息由id从小到大排序。
>
> xrange就是id从小到大返回排序	- +表示返回所有消息，也可指定id值返回，count用于控制返回消息个数

```sh
127.0.0.1:6379> XRANGE mystream - +	  #- + 表示返回流mystream中所有的消息，且根据id从小到大排序
1) 1) "1684919509306-0"
   2) 1) "name"
      2) "tom"
      3) "age"
      4) "20"
2) 1) "1684919517032-0"
   2) 1) "name"
      2) "mark"
      3) "age"
      4) "22"
3) 1) "1684919517032-1"
   2) 1) "name"
      2) "marry"
      3) "age"
      4) "18"
#按照指定的id范围内找	返回的消息由小到大排序      
127.0.0.1:6379> XRANGE mystream 1684919509306-0 1684919517032-0
1) 1) "1684919509306-0"
   2) 1) "name"
      2) "tom"
      3) "age"
      4) "20"
2) 1) "1684919517032-0"
   2) 1) "name"
      2) "mark"
      3) "age"
      4) "22"

127.0.0.1:6379> XRANGE mystream - + count 2		# 限制返回两个
1) 1) "1681003546319-0"
   2) 1) "name"
      2) "Alice"
      3) "age"
      4) "20"
2) 1) "1681003556153-0"
   2) 1) "name"
      2) "Bob"
      3) "age"
      4) "21"
```

------



#### XREVRANGE

**`XREVRANGE key end start [COUNT count]`**：返回给定id范围内流key的消息。

> 在`XREVRANGE`中，要先指定结束ID，再指定开始ID，返回消息的顺序是根据id从大到小排序。其余和XRANGE一样。
>
> 和xrange区别在于 要先指定最大的id，再指定最小的id，且返回的消息从大到小排序

```sh
127.0.0.1:6379> XREVRANGE mystream + -
1) 1) "1684919517032-1"
   2) 1) "name"
      2) "marry"
      3) "age"
      4) "18"
2) 1) "1684919517032-0"
   2) 1) "name"
      2) "mark"
      3) "age"
      4) "22"
3) 1) "1684919509306-0"
   2) 1) "name"
      2) "tom"
      3) "age"
      4) "20"

```

------



#### XDEL

**`XDEL key id [id ...]`**：从流key中删除指定id(消息)。

```sh
127.0.0.1:6379> xdel mystream 1684919517032-1
(integer) 1		# 成功删除一个
127.0.0.1:6379> XRANGE mystream - +
1) 1) "1684919509306-0"
   2) 1) "name"
      2) "tom"
      3) "age"
      4) "20"
2) 1) "1684919517032-0"
   2) 1) "name"
      2) "mark"
      3) "age"
      4) "22"
```

------



#### XLEN

**`XLEN mystream`**：返回流key中消息的条数。

```sh
127.0.0.1:6379> XLEN mystream	# 流mystream中有两条消息
(integer) 2
```

------



#### XTRIM

**`XTRIM key <MAXLEN | MINID> [= | ~] threshold [LIMIT count]`**：将流消息裁剪为指定数量的消息。

> MAXLEN：表示允许最大的消息长度(个数)，超过此数量会优先删除id较小的消息。即先获取最新的消息
>
> MINID：表示允许最小的id，比此id还小的消息会被删除。
>
> 返回值：删除消息的数量。

```sh
# 创建五条消息存入流mystream中
127.0.0.1:6379> xadd mystream * k1 v1 
"1684920267928-0"
127.0.0.1:6379> xadd mystream * k2 v2
"1684920274108-0"
127.0.0.1:6379> xadd mystream * k3 v3
"1684920277451-0"
127.0.0.1:6379> xadd mystream * k4 v4
"1684920281196-0"
127.0.0.1:6379> xadd mystream * k5 v5
"1684920284637-0"
127.0.0.1:6379> XTRIM mystream maxlen 3	#获取最近的3条消息，id较小的被删除（id是递增的）
(integer) 2		#删除了前两条id小的消息
127.0.0.1:6379> XRANGE mystream - +
1) 1) "1684920277451-0"
   2) 1) "k3"
      2) "v3"
2) 1) "1684920281196-0"
   2) 1) "k4"
      2) "v4"
3) 1) "1684920284637-0"
   2) 1) "k5"
      2) "v5"	
127.0.0.1:6379> XTRIM mystream minid 1684920281196-0	#获取id不小于1684920281196-0的消息
(integer) 1		#比指定id小的消息有1条，删除
127.0.0.1:6379> XRANGE mystream - +
1) 1) "1684920281196-0"
   2) 1) "k4"
      2) "v4"
2) 1) "1684920284637-0"
   2) 1) "k5"
      2) "v5"

```

------



#### XREAD(重！！)

**`XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id  [id ...]`**

> 从一个或者多个流中读取数据，仅返回id大于对应流中最大id的消息（也就是新添加的消息）。
>
> count：最多读取多少条
>
> block：是否以阻塞的方式读取，如果开启且block 0 阻塞时间设置为0，表示永远阻塞直到读取到消息。
>
> key：可同时传入多个key，同时进行读取满足条件的消息，比xrange好的点
>
> id：表示读取ID大于指定id的消息。	0-0或0或00或000都表示从最小的消息开始获取，不指定count，就返回stream中所有的消息。 $表示 返回 大于 当前stream中最大id的消息
>
> 特殊ID：符号`$`。表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil。一般用于阻塞队列获取新消息。

xread分为阻塞和非阻塞两种

##### 非阻塞：

```sh
# 数据准备，创建两个流mystream和mystream2
127.0.0.1:6379> xadd mystream * k1 v1
"1684920805754-0"
127.0.0.1:6379> xadd mystream * k2 v2
"1684920808755-0"
127.0.0.1:6379> xadd mystream * k3 v3
"1684920811338-0"
127.0.0.1:6379> xadd mystream * k4 v4
"1684920814131-0"
127.0.0.1:6379> xadd mystream * k5 v5
"1684920817146-0"
127.0.0.1:6379> xadd mystream * k6 v6
"1684920819961-0"
127.0.0.1:6379> xadd mysteam2 * m1 n1
"1684920841131-0"
127.0.0.1:6379> xadd mysteam2 * m2 n2
"1684920846487-0"
127.0.0.1:6379> xadd mysteam2 * m3 n3
"1684920849627-0"
127.0.0.1:6379> xadd mysteam2 * m4 n4
"1684920852462-0"

127.0.0.1:6379> XREAD count 2 streams mystream 0-0	# count 2表示只获取2个，0-0表示从最小的ID开始获取Stream中的消息
1) 1) "mystream"
   2) 1) 1) "1684920805754-0"
         2) 1) "k1"
            2) "v1"
      2) 1) "1684920808755-0"
         2) 1) "k2"
            2) "v2"

            
127.0.0.1:6379> XREAD count 3 streams mystream 0		# 使用0也可以表示从最小的ID开始获取Stream中的消息，000也可以
1) 1) "mystream"
   2) 1) 1) "1684920805754-0"
         2) 1) "k1"
            2) "v1"
      2) 1) "1684920808755-0"
         2) 1) "k2"
            2) "v2"
            
127.0.0.1:6379> XREAD count 3 streams mystream $		# $表示读取大于当前流中最大的id的消息
(nil)		#当前mystream没有比最大id还大的消息，所以返回nil


```

##### 阻塞：

```sh
# 读取stream1中id大于1681006080120-2的三条消息，读取stream2中id大于1681008731850-3的三条消息
127.0.0.1:6379> XREAD count 3 block 0 streams stream1 stream2 1681006080120-2 1681008731850-3
1) 1) "stream1"					# 读取到了stream1中id大于1681006080120-2的3条消息（如果有多条则读取最新的消息）
   2) 1) 1) "1681006080120-3"
         2) 1) "name"
            2) "Davie"
      2) 1) "1681006080120-4"
         2) 1) "name"
            2) "Eric"
      3) 1) "1681008731850-0"
         2) 1) "name"
            2) "Jack"
2) 1) "stream2"					# stream2中有两条id大于1681008731850-3的消息
   2) 1) 1) "1681008731850-4"
         2) 1) "5"
            2) "five"
      2) 1) "1681008731850-5"
         2) 1) "6"
            2) "six"



# 加入阻塞选项，此时敲下回车，客户端会阻塞等待，什么都不显示，也不能操作
127.0.0.1:6379> XREAD count 3 block 0  streams mystream $ 
#这时打开新的客户端(新的终端) 登录redis	并为mystream存入一条消息
127.0.0.1:6379> xadd mystream * k8 v8
"1684921512648-0"
#这时回到之前的客户端，发现显示了新存入的消息	即$显示了最新存入的消息 而block 0 表示一直阻塞，直到有新的消息存入，即有大于当前最大id的消息
1) 1) "mystream"
   2) 1) 1) "1684921512648-0"	# 读取到了一条消息
         2) 1) "k8"
            2) "v8"
(45.34s)	# 等待了45.34s


```

***





### 消费者常用命令：

#### XGROUP

**`XGROUP CREATE key group <id | $> `**：创建消费者组。

> 最后一个参数是要考虑已传递的流中最后一项的ID。
>
> $表示从Stream尾部开始消费，$的作用和生产者XREAD中一样，读取大于当前stream中最大id的消息
> 在这种情况下，从该消费者组获取数据的消费者只能看到到达流的新元素。
>
> 0表示从Stream头部开始消费，消费者组可以获取整个流的历史记录。
>
> 创建消费者组的时候必须指定 ID, ID 为 0 表示从头开始消费，为 $ 表示只消费新的消息。

```sh
# 创建消费者组
127.0.0.1:6379> XGROUP create mystream groupA $
OK
127.0.0.1:6379> XGROUP create mystream groupB 0
OK
127.0.0.1:6379> XGROUP create mystream groupC 0
OK
```

**`XGROUP CREATECONSUMER key group consumer`**：创建消费者。

```sh
127.0.0.1:6379> XGROUP CREATECONSUMER mystream1 groupA consumerA	#在流mystream1的groupA中创建消费者consumerA
(integer) 1
127.0.0.1:6379> XINFO CONSUMERS mystream1 groupA	# 查看流mystream1的消费组groupA的消费者信息
1) 1) "name"
   2) "consumerA"	# 消费者名称
   3) "pending"		
   4) (integer) 0	# 消费者读取消息的数量（此时还未读取消息，所以为0）
   5) "idle"
   6) (integer) 26277
```

**`XGROUP DESTORY key group`**：删除流key中指定的消费组。

```sh
127.0.0.1:6379> XGROUP create mystream1 groupC 0	# 在流stream1中创建消费组groupC
OK
# 删除消费组
127.0.0.1:6379> XGROUP DESTROY mystream1 groupC	# 删除流stream1中的消费组groupC
(integer) 1		# 返回删除的个数
```

**`XGROUP DELCONSUMER key group consumer`**：删除流key中消费组group的指定消费者。

```sh
127.0.0.1:6379> XGROUP CREATECONSUMER mystream1 groupA consumerA
(integer) 1
127.0.0.1:6379> XGROUP DELCONSUMER mystream1 groupA consumerA
(integer) 0		
127.0.0.1:6379> XINFO CONSUMERS mystream1 groupA
(empty array)	# 消费者consumerA已经被删除
```



------



#### XREADGROUP(重！！！)

**`XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds]
[NOACK] STREAMS key [key ...] id [id ...]`**

> 读取消费者组中的消息。		消费者不需要我们自己建立，只要写了consumer1，会自动帮我们创建
>
> 消费者不存在则自动创建该消费者。
>
> 特殊ID：`>`表示从第一条未被消费的消息开始读取。

```sh
# 创建消费组
127.0.0.1:6379> XGROUP create mystream groupA $
OK
127.0.0.1:6379> XGROUP create mystream groupB 0
OK
127.0.0.1:6379> XGROUP create mystream groupC 0
OK

# 消费组groupA内的消费者consumer1从mystream消息队列中读取所有信息，消费组会自动帮我们创建consumer1消费者
127.0.0.1:6379> XREADGROUP GROUP groupA consumer1 STREAMS mystream  >	# >表示从第一条未被消费的消息开始读取。
1) 1) "stream1"
   2) 1) 1) "1681006080120-0"
         2) 1) "name"
            2) "Alice"
      2) 1) "1681006080120-1"
         2) 1) "name"
            2) "Bob"
      3) 1) "1681006080120-2"
         2) 1) "name"
            2) "Cindy"
      4) 1) "1681006080120-3"
         2) 1) "name"
            2) "Davie"
      5) 1) "1681006080120-4"
         2) 1) "name"
            2) "Eric"
      6) 1) "1681008731850-0"
         2) 1) "name"
            2) "Jack"
#这时，consumer1读取完全部的消息，消费组中的游标指向了最后，而消费组中的每个消费者是共用一个游标，当一个消费者读取完，其他的消费者就读取不到消息了
127.0.0.1:6379> XREADGROUP GROUP groupA consumer2 STREAMS mystream  >	
(nil)	# 已经被消费者cumstomer1消费完了，所以返回nil


# 创建消费组
127.0.0.1:6379> XGROUP create mystream groupA 0
OK
127.0.0.1:6379> XGROUP create mystream groupB 0
OK

# 让组内的多个消费者共同分担读取消息，所以让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的，即让每个消费者读取部分消息，不让一个消费者读取全部消息  
127.0.0.1:6379> XREADGROUP group groupC consumer1 count 2 STREAMS mystream >  #限制读取3个 
1) 1) "mystream"
   2) 1) 1) "1684920805754-0"
         2) 1) "k1"
            2) "v1"
      2) 1) "1684920808755-0"
         2) 1) "k2"
            2) "v2"
127.0.0.1:6379> XREADGROUP group groupC consumer2 count 2 STREAMS mystream >
1) 1) "mystream"
   2) 1) 1) "1684920811338-0"
         2) 1) "k3"
            2) "v3"
      2) 1) "1684920814131-0"
         2) 1) "k4"
            2) "v4"
127.0.0.1:6379> XREADGROUP group groupC consumer3 count 2 STREAMS mystream >
1) 1) "mystream"
   2) 1) 1) "1684920817146-0"
         2) 1) "k5"
            2) "v5"
      2) 1) "1684920819961-0"
         2) 1) "k6"
            2) "v6"
127.0.0.1:6379> XREADGROUP group groupC consumer4 count 2 STREAMS mystream >
1) 1) "mystream"
   2) 1) 1) "1684921512648-0"
         2) 1) "k8"
            2) "v8"
127.0.0.1:6379> XREADGROUP group groupC consumer5 count 2 STREAMS mystream >
(nil)		# 已经没有消息可读，返回nil
	
```

------



#### XPENDING

**`XPENDING key group`**：返回待处理消息相关信息。（读取到的消息没有经过XACK确认即为待处理消息）

即读取了，但是还未发送ack消息的消息

> 返回一组数据，包括消费组待处理消息的数量、所有消费者读取的消息最小id、所有消费者所读取id的最大值、每个消费者待处理消息的数量。

```sh
127.0.0.1:6379> XPENDING stream1 groupA
1) (integer) 6			# 待处理消息数
2) "1681006080120-0"	
3) "1681008731850-0"	
4) 1) 1) "consumer1"	
      2) "6"			
127.0.0.1:6379> XPENDING stream2 groupA
1) (integer) 6			# 待处理消息数
2) "1681008731850-0"	# 待处理消息最小id
3) "1681008731850-5"	# 待处理消息最大id
4) 1) 1) "consumer1"	# 消费者consumer1
      2) "3"			# 消费者consumer1有3条待处理消息
   2) 1) "consumer2"	# 消费者consumer2
      2) "3"			# 消费者consumer2有3条待处理消息
127.0.0.1:6379> XPENDING mystream groupC
1) (integer) 7		# 待处理消息数 即未被确认的消息
2) "1684920805754-0"	# 待处理消息最小id
3) "1684921512648-0"	# 待处理消息最大id
4) 1) 1) "consumer1"	# 消费者consumer1
      2) "2"			# 消费者consumer1有2条待处理消息
   2) 1) "consumer2"	# 消费者consumer2
      2) "2"			# 消费者consumer2有2条待处理消息
   3) 1) "consumer3"	# 消费者consumer3
      2) "2"			# 消费者consumer3有2条待处理消息
   4) 1) "consumer4"	# 消费者consumer4
      2) "1"			# 消费者consumer4有1条待处理消息
```

**`XPENDING key group start end count consumer`**：查看指定消费者具体读取了哪些数据

```sh
# 查看消费者consumer1具体读取了哪些数据
127.0.0.1:6379> XPENDING mystream groupC - + 5 consumer1
#查看groupA组consumer1具体读取了哪些数据，设置最大返回5条	- +表示全部数据
1) 1) "1684920805754-0"
   2) "consumer1"
   3) (integer) 285653
   4) (integer) 1
2) 1) "1684920808755-0"
   2) "consumer1"
   3) (integer) 285653
   4) (integer) 1

```

------



#### XACK

**`XACK key group id [id ...]`**：向消息队列确认id对应的消息已处理完成，XACK会从待处理消息列表中删除该消息。	只是从XPENDING数组中删除消息，而不是删除队列中的消息

> 返回值：该命令返回成功确认的消息数。

```sh
127.0.0.1:6379> XACK mystream groupC 1684920805754-0 #确认1684920805754-0消息被处理，发送ACK消息
(integer) 1		#一条消息被移除待处理队列	从XPENDING数组中删除消息

127.0.0.1:6379> XPENDING mystream groupC - + 5 consumer1
1) 1) "1684920808755-0"
   2) "consumer1"
   3) (integer) 405336
   4) (integer) 1		#删除了一条消息
```

------












